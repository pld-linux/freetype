--- freetype-2.1.9/src/bdf/bdflib.c.cve-2006-1861	2004-06-22 06:28:17.000000000 -0600
+++ freetype-2.1.9/src/bdf/bdflib.c	2006-06-08 12:50:32.714640440 -0600
@@ -1098,6 +1098,7 @@
 #define ERRMSG1  "[line %ld] Missing \"%s\" line.\n"
 #define ERRMSG2  "[line %ld] Font header corrupted or missing fields.\n"
 #define ERRMSG3  "[line %ld] Font glyphs corrupted or missing fields.\n"
+#define ERRMSG4  "[line %ld] BBX too big.\n"
 
 
   static FT_Error
@@ -1570,6 +1571,14 @@
         goto Exit;
       p->glyph_enc = _bdf_atol( p->list.field[1], 0, 10 );
 
+      /* Check that the encoding is in the range [0,65536] because        */
+      /* otherwise p->have (a bitmap with static size) overflows.         */
+      if ( p->glyph_enc >= sizeof(p->have)*8 )
+      {
+        error = BDF_Err_Invalid_File_Format;
+        goto Exit;
+      }
+
       /* Check to see whether this encoding has already been encountered. */
       /* If it has then change it to unencoded so it gets added if        */
       /* indicated.                                                       */
@@ -1820,6 +1829,8 @@
     /* And finally, gather up the bitmap. */
     if ( ft_memcmp( line, "BITMAP", 6 ) == 0 )
     {
+      unsigned long  bitmap_size;
+
       if ( !( p->flags & _BDF_BBX ) )
       {
         /* Missing BBX field. */
@@ -1830,7 +1841,16 @@
 
       /* Allocate enough space for the bitmap. */
       glyph->bpr   = ( glyph->bbx.width * p->font->bpp + 7 ) >> 3;
-      glyph->bytes = (unsigned short)( glyph->bpr * glyph->bbx.height );
+
+      bitmap_size = glyph->bpr * glyph->bbx.height;
+      if ( bitmap_size > 0xFFFFU )
+      {
+        FT_ERROR(( "_bdf_parse_glyphs: " ERRMSG4, lineno ));
+        error = BDF_Err_Bbx_Too_Big;
+        goto Exit;
+      }
+      else
+        glyph->bytes = (unsigned short)bitmap_size;
 
       if ( FT_NEW_ARRAY( glyph->bitmap, glyph->bytes ) )
         goto Exit;
--- freetype-2.1.9/src/cff/cffgload.h.cve-2006-1861	2004-05-13 15:59:17.000000000 -0600
+++ freetype-2.1.9/src/cff/cffgload.h	2006-06-08 12:50:32.714640440 -0600
@@ -196,7 +196,7 @@ FT_BEGIN_HEADER
   FT_LOCAL( FT_Error )
   cff_slot_load( CFF_GlyphSlot  glyph,
                  CFF_Size       size,
-                 FT_Int         glyph_index,
+                 FT_UInt        glyph_index,
                  FT_Int32       load_flags );
 
 
--- freetype-2.1.10/src/cff/cffload.c.cve-2006-1861	2006-06-08 12:50:32.703642430 -0600
+++ freetype-2.1.10/src/cff/cffload.c	2006-06-08 12:52:52.338376597 -0600
@@ -1688,6 +1688,8 @@
 
       for ( i = 0; i < num_glyphs; i++ )
         charset->cids[charset->sids[i]] = (FT_UShort)i;
+
+      charset->max_cid = max_cid;
     }
 
   Exit:
@@ -2011,7 +2013,7 @@
 
     if ( error )
       goto Exit;
-
+ 
     /* if it is a CID font, we stop there */
     if ( top->cid_registry != 0xFFFFU )
       goto Exit;
--- freetype-2.1.9/src/cff/cffgload.c.cve-2006-1861	2004-05-13 15:59:17.000000000 -0600
+++ freetype-2.1.9/src/cff/cffgload.c	2006-06-08 12:50:32.717639897 -0600
@@ -2284,7 +2284,7 @@
   FT_LOCAL_DEF( FT_Error )
   cff_slot_load( CFF_GlyphSlot  glyph,
                  CFF_Size       size,
-                 FT_Int         glyph_index,
+                 FT_UInt        glyph_index,
                  FT_Int32       load_flags )
   {
     FT_Error      error;
@@ -2330,7 +2330,7 @@
 
         error = sfnt->load_sbit_image( face,
                                        (FT_ULong)size->strike_index,
-                                       (FT_UInt)glyph_index,
+                                       glyph_index,
                                        (FT_Int)load_flags,
                                        stream,
                                        &glyph->root.bitmap,
@@ -2393,7 +2393,12 @@
       /* subsetted font, glyph_indices and CIDs are identical, though */
       if ( cff->top_font.font_dict.cid_registry != 0xFFFFU &&
            cff->charset.cids )
-        glyph_index = cff->charset.cids[glyph_index];
+      {
+        if ( glyph_index < cff->charset.max_cid )
+          glyph_index = cff->charset.cids[glyph_index];
+        else
+          glyph_index = 0;
+      }
 
       cff_decoder_init( &decoder, face, size, glyph, hinting,
                         FT_LOAD_TARGET_MODE( load_flags ) );
--- freetype-2.1.9/src/cff/cfftypes.h.cve-2006-1861	2003-12-20 00:30:05.000000000 -0700
+++ freetype-2.1.9/src/cff/cfftypes.h	2006-06-08 12:50:32.717639897 -0600
@@ -84,6 +84,7 @@ FT_BEGIN_HEADER
     FT_UShort*  sids;
     FT_UShort*  cids;       /* the inverse mapping of `sids'; only needed */
                             /* for CID-keyed fonts                        */
+    FT_UInt     max_cid;
   } CFF_CharsetRec, *CFF_Charset;
 
 
--- freetype-2.1.9/include/freetype/fterrdef.h.cve-2006-1861	2004-02-12 01:33:20.000000000 -0700
+++ freetype-2.1.9/include/freetype/fterrdef.h	2006-06-08 12:50:32.718639716 -0600
@@ -226,6 +226,8 @@
                 "`ENCODING' field missing" )
   FT_ERRORDEF_( Missing_Bbx_Field,                           0xB6, \
                 "`BBX' field missing" )
+  FT_ERRORDEF_( Bbx_Too_Big,                                 0xB7, \
+                "`BBX' too big" )
 
 
 /* END */
